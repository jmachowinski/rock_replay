#include "LogTask.hpp"
#include <rtt/typelib/TypelibMarshallerBase.hpp>
#include <rtt/types/Types.hpp>
#include <rtt/TaskContext.hpp>
#include <rtt/transports/corba/TaskContextServer.hpp>
#include <rtt/transports/corba/CorbaDispatcher.hpp>
#include <rtt/base/OutputPortInterface.hpp>

class PortHandle
{
public:
    std::string name;
    orogen_transports::TypelibMarshallerBase *transport;
    RTT::base::DataSourceBase::shared_ptr sample;
    orogen_transports::TypelibMarshallerBase::Handle *transportHandle;
    RTT::base::OutputPortInterface *port;
};


LogTask::LogTask(const std::string& name)
{
    task = new RTT::TaskContext(name);
        
    RTT::corba::TaskContextServer::Create( task );
    RTT::corba::CorbaDispatcher::Instance( task->ports(), ORO_SCHED_OTHER, RTT::os::LowestPriority );
}

bool LogTask::createReplayPort(const std::string& portname, const std::string& typestr, PortHandle &handle)
{
    RTT::types::TypeInfoRepository::shared_ptr ti = RTT::types::TypeInfoRepository::Instance();
    RTT::types::TypeInfo* type = ti->type(typestr);
    if (! type)
    {
        std::cerr << "cannot find " << typestr << " in the type info repository" << std::endl;
        return false;
    }
    
    RTT::base::PortInterface *testIfExists = task->ports()->getPort(portname);
    if(testIfExists) {
        std::cerr << "port with name " << portname << " already exists" << std::endl;
        return false;
    }

    RTT::base::OutputPortInterface *writer= type->outputPort(portname);
    orogen_transports::TypelibMarshallerBase* transport =
        dynamic_cast<orogen_transports::TypelibMarshallerBase*>(type->getProtocol(orogen_transports::TYPELIB_MARSHALLER_ID));
    if (! transport)
    {
        log(RTT::Error) << "cannot report ports of type " << type->getTypeName() << " as no typekit generated by orogen defines it" << RTT::endlog();
        return false;
    }

    //TODO check if local type is same as logfile type
    
//     m_registry->merge(transport->getRegistry());
//     if (! m_registry->has(transport->getMarshallingType()))
//     {
//         log(RTT::Error) << "cannot report ports of type " << type->getTypeName() << " as I can't find a typekit Typelib registry that defines it" << RTT::endlog();
//         return false;
//     }

    task->ports()->addPort(writer->getName(), *writer);

    try {
        handle.name = writer->getName();
        handle.port = writer;
        handle.transportHandle = transport->createSample();
        handle.transport = transport;
        handle.sample = transport->getDataSource(handle.transportHandle);
    } catch ( RTT::internal::bad_assignment& ba ) {
        return false;
    }
    return true;
}

bool LogTask::addStream(const pocolog_cpp::InputDataStream& stream)
{
    size_t idx = stream.getIndex();
    
    if(idx >= handles.size())
    {
        handles.resize(idx+1, nullptr);
    }

    PortHandle *handle = new PortHandle;
    
    size_t nameStart = stream.getName().find_last_of('.') + 1;
    std::string portName = stream.getName().substr(nameStart, stream.getName().size());
    
    std::string type = stream.getType()->getName();
    if(type.size() > 2 && type.substr(type.size() - 2, type.size()) == "_m")
        type = type.substr(0, type.size() - 2);
    
    if(!createReplayPort(portName, type, *handle))
    {
        delete handle;
        throw std::runtime_error("Error, could not create replay port");
        return false;
    }

    std::cout << "Created port " << idx << " name " << portName << std::endl;
    
    handles[idx] = handle;
    
    return true;
}

void LogTask::replaySample(pocolog_cpp::InputDataStream& stream, size_t sampleNr)
{
    size_t idx = stream.getIndex();
    std::cout << "TaskName is " << task->getName() << " streamName " << stream.getName() << " idx " << idx << std::endl; 
    
    if(idx >= handles.size() || !handles[idx])
    {
        throw std::runtime_error("LogTask::replaySample Error, got stream with unregistered index");
    }

    PortHandle &handle(*handles[idx]);
    //optimization, do nothing if nobody is listening to this port
    if(!handle.port->connected())
        return;
    
    std::vector<uint8_t> data;
    if(!stream.getSampleData(data, sampleNr))
    {
        std::cout << "Warning, could not replay sample: " << stream.getName() << " " << sampleNr <<  std::endl;
        return;
    }
    
    try {
        handle.transport->unmarshal(data, handle.transportHandle);
    } catch (...) {
        std::cout << "caught marshall error.." << std::endl;
        return;
    }

    handle.port->write(handle.sample);
}
